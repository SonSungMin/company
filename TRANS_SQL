/*
================================================================================
함수명: MOVE_COORDS_TO_BBOX
설  명: TM좌표를 A좌표의 바운딩 박스 중심으로 이동 및 회전시키는 함수
작성일: 2025-11-05
================================================================================
파라미터:
    p_coords_a (CLOB)   : 기준이 되는 A좌표 (형식: x,y;x,y;x,y;...)
    p_coords_b (CLOB)   : 이동할 대상 B좌표 (형식: x,y;x,y;x,y;...)
    p_apply_rotation (NUMBER) : 회전 적용 여부 (1:적용, 0:미적용, 기본값:0)
    
반환값:
    CLOB : A좌표의 바운딩 박스 중심으로 이동 및 회전된 새로운 B좌표
    
동작원리:
    1. A좌표의 바운딩 박스 → 왼쪽위, 오른쪽위 점으로 상단 모서리의 기울기 계산
    2. B좌표를 A의 중심으로 이동
    3. 이동된 B 바운딩 박스 → 상단 모서리의 기울기 계산
    4. 두 기울기(각도) 비교하여 회전 필요 여부 판단
    5. 필요시 A의 중심을 기준으로 회전
    
사용예시:
    -- 이동만 적용
    SELECT MOVE_COORDS_TO_BBOX(
        '100,200;150,250;200,300',
        '10,20;30,40;50,60',
        0
    ) FROM DUAL;
    
    -- 이동 + 회전 적용
    SELECT MOVE_COORDS_TO_BBOX(
        '100,200;150,250;200,300',
        '10,20;30,40;50,60',
        1
    ) FROM DUAL;
================================================================================
*/
CREATE OR REPLACE FUNCTION MOVE_COORDS_TO_BBOX(
    p_coords_a CLOB,              -- 기준 좌표
    p_coords_b CLOB,              -- 이동할 좌표
    p_apply_rotation NUMBER DEFAULT 0  -- 회전 적용 여부 (1:적용, 0:미적용)
) RETURN CLOB
IS
    -- 반환할 결과 CLOB
    v_result CLOB;
    
    -- A좌표의 바운딩 박스
    v_a_min_x NUMBER := 999999999;
    v_a_min_y NUMBER := 999999999;
    v_a_max_x NUMBER := -999999999;
    v_a_max_y NUMBER := -999999999;
    v_a_center_x NUMBER;
    v_a_center_y NUMBER;
    
    -- A 바운딩 박스의 4개 꼭지점
    v_a_left_top_x NUMBER;      -- 왼쪽 위
    v_a_left_top_y NUMBER;
    v_a_right_top_x NUMBER;     -- 오른쪽 위
    v_a_right_top_y NUMBER;
    v_a_right_bottom_x NUMBER;  -- 오른쪽 아래
    v_a_right_bottom_y NUMBER;
    v_a_left_bottom_x NUMBER;   -- 왼쪽 아래
    v_a_left_bottom_y NUMBER;
    
    -- A 바운딩 박스의 회전각도 (상단 모서리의 기울기로 계산)
    v_a_rotation NUMBER := 0;
    
    -- B좌표의 바운딩 박스
    v_b_min_x NUMBER := 999999999;
    v_b_min_y NUMBER := 999999999;
    v_b_max_x NUMBER := -999999999;
    v_b_max_y NUMBER := -999999999;
    v_b_center_x NUMBER;
    v_b_center_y NUMBER;
    
    -- 이동 후 B 바운딩 박스의 4개 꼭지점
    v_moved_b_left_top_x NUMBER;
    v_moved_b_left_top_y NUMBER;
    v_moved_b_right_top_x NUMBER;
    v_moved_b_right_top_y NUMBER;
    
    -- 이동 후 B 바운딩 박스의 회전각도
    v_moved_b_rotation NUMBER := 0;
    
    -- 실제 적용할 회전각도
    v_rotation_diff NUMBER := 0;
    
    -- 좌표 파싱용 임시 변수
    v_coord_pair VARCHAR2(4000);
    v_x NUMBER;
    v_y NUMBER;
    
    -- 이동 및 회전 계산용
    v_moved_x NUMBER;
    v_moved_y NUMBER;
    v_final_x NUMBER;
    v_final_y NUMBER;
    
    -- 문자열 파싱용 변수
    v_pos NUMBER;
    v_temp_coords CLOB;
    
    -- B좌표 저장용
    TYPE t_coord_array IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    v_b_x_array t_coord_array;
    v_b_y_array t_coord_array;
    v_b_count NUMBER := 0;
    
BEGIN
    /*
    ============================================================================
    1단계: A좌표의 바운딩 박스 계산
    ============================================================================
    - A좌표의 최소/최대 x, y 값으로 바운딩 박스 산출
    - 4개 꼭지점 좌표 계산
    */
    v_temp_coords := p_coords_a;
    
    LOOP
        v_pos := INSTR(v_temp_coords, ';');
        
        IF v_pos > 0 THEN
            v_coord_pair := SUBSTR(v_temp_coords, 1, v_pos - 1);
            v_temp_coords := SUBSTR(v_temp_coords, v_pos + 1);
        ELSE
            v_coord_pair := v_temp_coords;
        END IF;
        
        v_x := TO_NUMBER(SUBSTR(v_coord_pair, 1, INSTR(v_coord_pair, ',') - 1));
        v_y := TO_NUMBER(SUBSTR(v_coord_pair, INSTR(v_coord_pair, ',') + 1));
        
        -- 바운딩 박스 최소/최대값 갱신
        IF v_x < v_a_min_x THEN v_a_min_x := v_x; END IF;
        IF v_x > v_a_max_x THEN v_a_max_x := v_x; END IF;
        IF v_y < v_a_min_y THEN v_a_min_y := v_y; END IF;
        IF v_y > v_a_max_y THEN v_a_max_y := v_y; END IF;
        
        EXIT WHEN v_pos = 0;
    END LOOP;
    
    -- A 바운딩 박스의 중심점
    v_a_center_x := (v_a_min_x + v_a_max_x) / 2;
    v_a_center_y := (v_a_min_y + v_a_max_y) / 2;
    
    -- A 바운딩 박스의 4개 꼭지점 좌표
    -- 주의: TM좌표계에서 Y값이 클수록 위쪽
    v_a_left_top_x := v_a_min_x;      -- 왼쪽 위 (x작음, y큼)
    v_a_left_top_y := v_a_max_y;
    
    v_a_right_top_x := v_a_max_x;     -- 오른쪽 위 (x큼, y큼)
    v_a_right_top_y := v_a_max_y;
    
    v_a_right_bottom_x := v_a_max_x;  -- 오른쪽 아래 (x큼, y작음)
    v_a_right_bottom_y := v_a_min_y;
    
    v_a_left_bottom_x := v_a_min_x;   -- 왼쪽 아래 (x작음, y작음)
    v_a_left_bottom_y := v_a_min_y;
    
    /*
    ============================================================================
    2단계: A 바운딩 박스의 회전각도 계산 (회전 적용 시)
    ============================================================================
    - 상단 모서리 (왼쪽위 → 오른쪽위)의 기울기로 회전각도 계산
    - atan2를 사용하여 각도 산출
    */
    IF p_apply_rotation = 1 THEN
        -- 상단 모서리의 벡터: (오른쪽위 - 왼쪽위)
        -- atan2(dy, dx) = 벡터의 각도
        v_a_rotation := ATAN2(
            v_a_right_top_y - v_a_left_top_y,  -- dy
            v_a_right_top_x - v_a_left_top_x   -- dx
        );
    END IF;
    
    /*
    ============================================================================
    3단계: B좌표의 바운딩 박스 계산 및 좌표 저장
    ============================================================================
    */
    v_temp_coords := p_coords_b;
    
    LOOP
        v_pos := INSTR(v_temp_coords, ';');
        
        IF v_pos > 0 THEN
            v_coord_pair := SUBSTR(v_temp_coords, 1, v_pos - 1);
            v_temp_coords := SUBSTR(v_temp_coords, v_pos + 1);
        ELSE
            v_coord_pair := v_temp_coords;
        END IF;
        
        v_x := TO_NUMBER(SUBSTR(v_coord_pair, 1, INSTR(v_coord_pair, ',') - 1));
        v_y := TO_NUMBER(SUBSTR(v_coord_pair, INSTR(v_coord_pair, ',') + 1));
        
        IF v_x < v_b_min_x THEN v_b_min_x := v_x; END IF;
        IF v_x > v_b_max_x THEN v_b_max_x := v_x; END IF;
        IF v_y < v_b_min_y THEN v_b_min_y := v_y; END IF;
        IF v_y > v_b_max_y THEN v_b_max_y := v_y; END IF;
        
        v_b_count := v_b_count + 1;
        v_b_x_array(v_b_count) := v_x;
        v_b_y_array(v_b_count) := v_y;
        
        EXIT WHEN v_pos = 0;
    END LOOP;
    
    v_b_center_x := (v_b_min_x + v_b_max_x) / 2;
    v_b_center_y := (v_b_min_y + v_b_max_y) / 2;
    
    /*
    ============================================================================
    4단계: B를 A의 중심으로 이동 후, 이동된 B 바운딩 박스의 회전각도 계산
    ============================================================================
    - B 바운딩 박스의 꼭지점을 A의 중심으로 이동
    - 이동된 상단 모서리의 기울기로 회전각도 계산
    - A와 비교하여 회전 필요 여부 판단
    */
    IF p_apply_rotation = 1 THEN
        -- B 바운딩 박스의 왼쪽위 점을 A의 중심 기준으로 이동
        v_moved_b_left_top_x := (v_b_min_x - v_b_center_x) + v_a_center_x;
        v_moved_b_left_top_y := (v_b_max_y - v_b_center_y) + v_a_center_y;
        
        -- B 바운딩 박스의 오른쪽위 점을 A의 중심 기준으로 이동
        v_moved_b_right_top_x := (v_b_max_x - v_b_center_x) + v_a_center_x;
        v_moved_b_right_top_y := (v_b_max_y - v_b_center_y) + v_a_center_y;
        
        -- 이동된 B 바운딩 박스의 상단 모서리 기울기로 회전각도 계산
        v_moved_b_rotation := ATAN2(
            v_moved_b_right_top_y - v_moved_b_left_top_y,  -- dy
            v_moved_b_right_top_x - v_moved_b_left_top_x   -- dx
        );
        
        -- A와 이동된 B의 회전각도 차이 계산
        v_rotation_diff := v_a_rotation - v_moved_b_rotation;
        
        -- 각도를 -π ~ π 범위로 정규화
        WHILE v_rotation_diff > 3.14159265359 LOOP
            v_rotation_diff := v_rotation_diff - 6.28318530718;
        END LOOP;
        WHILE v_rotation_diff < -3.14159265359 LOOP
            v_rotation_diff := v_rotation_diff + 6.28318530718;
        END LOOP;
        
        -- 180도 회전도 같은 방향으로 간주 (사각형의 대칭성)
        IF ABS(v_rotation_diff) > 3.05432619099 THEN  -- 약 175도
            IF v_rotation_diff > 0 THEN
                v_rotation_diff := v_rotation_diff - 3.14159265359;
            ELSE
                v_rotation_diff := v_rotation_diff + 3.14159265359;
            END IF;
        END IF;
        
        -- 90도 배수도 체크 (사각형은 90도 회전해도 같은 모양)
        -- 85~95도 범위면 90도로 간주하여 조정
        IF ABS(ABS(v_rotation_diff) - 1.57079632679) < 0.087266 THEN  -- 90도±5도
            IF v_rotation_diff > 0 THEN
                v_rotation_diff := v_rotation_diff - 1.57079632679;
            ELSE
                v_rotation_diff := v_rotation_diff + 1.57079632679;
            END IF;
        END IF;
        
        -- 각도 차이가 5도 미만이면 회전하지 않음
        IF ABS(v_rotation_diff) < 0.087266 THEN  -- 약 5도
            v_rotation_diff := 0;
        END IF;
    END IF;
    
    /*
    ============================================================================
    5단계: B좌표 변환 (A의 중심으로 이동 → 회전)
    ============================================================================
    - B의 모든 점을 A의 중심으로 이동
    - 필요시 A의 중심을 기준으로 회전
    */
    DBMS_LOB.CREATETEMPORARY(v_result, TRUE);
    
    FOR i IN 1..v_b_count LOOP
        -- 단계 1: B를 A의 중심으로 이동
        v_moved_x := (v_b_x_array(i) - v_b_center_x) + v_a_center_x;
        v_moved_y := (v_b_y_array(i) - v_b_center_y) + v_a_center_y;
        
        -- 단계 2: 회전 적용 (필요시, A의 중심을 기준으로)
        IF p_apply_rotation = 1 AND v_rotation_diff != 0 THEN
            -- 회전 변환: A의 중심을 원점으로 → 회전 → 다시 A의 중심으로
            v_final_x := (v_moved_x - v_a_center_x) * COS(v_rotation_diff) - 
                        (v_moved_y - v_a_center_y) * SIN(v_rotation_diff) + v_a_center_x;
            v_final_y := (v_moved_x - v_a_center_x) * SIN(v_rotation_diff) + 
                        (v_moved_y - v_a_center_y) * COS(v_rotation_diff) + v_a_center_y;
        ELSE
            v_final_x := v_moved_x;
            v_final_y := v_moved_y;
        END IF;
        
        -- 결과 CLOB에 추가
        IF i > 1 THEN
            DBMS_LOB.APPEND(v_result, ';');
        END IF;
        
        DBMS_LOB.APPEND(v_result, TO_CHAR(v_final_x) || ',' || TO_CHAR(v_final_y));
    END LOOP;
    
    RETURN v_result;
    
EXCEPTION
    WHEN OTHERS THEN
        IF DBMS_LOB.ISTEMPORARY(v_result) = 1 THEN
            DBMS_LOB.FREETEMPORARY(v_result);
        END IF;
        RAISE;
END MOVE_COORDS_TO_BBOX;
/
